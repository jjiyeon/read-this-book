# 컴포넌트

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다. 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자다. 컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사

프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항 중 하나였다. 이 시절에는 프로그램의 위치가 한번 결정되면, 재배치가 불가능 했다.

구시대에는 라이브러리 함수에 접근하려면, 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다. 라이브러리는 바이너리가 아니라 소스 코드 형태로 유지되었다. 물론 메모리가 비싸서 이 접근법에는 문제가 있었다. 컴파일러가 느린 장치를 이용해서 소스코드를 여러번 읽어야 했고, 당연히 느렸다. 그러다가 프로그래머는 컴파일 시간을 단축하기 위해 함수 라이브러리를 개별적으로 컴파일하고 컴파일된 바이너리를 메모리의 특정 위치에 로드했다. 하지만 애플리케이션이 커지면????

여기서 해결책은 재배치가 가능한 바이너리였다. 지능적 로더를 사용해서 메모리에 재배치 할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는것. 이렇게 링킹로더가 탄생했다.

하지만 우리의 프로그램은 훨씬 커지게 되었다. 링킹로더가 느릴정도로. `컴파일하고 링크하는 데 사용 가능한 시간을 모두 소모할 때까지 프로그램은 커진다. `

이 이후로 디스크는 작아지기 시작했고 컴퓨터 메모리는 말도 안될 정도로 저렴해져서 디스크에 저장된 많은 데이터를 모두 램에 캐싱할 수 있을 정도였다. 이렇게 액티브 x와 공유 라이브러리 시대가 열렸고 .jar 파일도 등장하기 시작했다. 이렇게 컴포넌트 플러그인 아키텍처가 탄생했다.

### 결론

여기까지 오는데 50년 걸렸다. 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.
