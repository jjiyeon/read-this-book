# 14. 컴포넌트 결합

지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.

## ADP: 의존성 비순환 원칙

> 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.

하루 종일 일해서 무언가 작동하게 만들어 놓고 퇴근했는데, 이튿날 출근해 보면 전혀 돌아가지 않는 경험을 해본 적이 있지 않은가? 누군가가 당신이 의존하고 있던 무언가를 수정했기 때문이다. 이런 현상을 여기서는 `숙취증후군` 이라고 부른다.

소수의 개발자로 구성된 팀이라면 크게 문제가 되지 않지만, 팀이 커지면 이 숙취는 지독한 악몽이 될 수도 있다. 여기서 이 문제의 해결책으로 두가지 방법이 발전되어 왔는데, `주 단위 빌드` 와 `의존성 비순환 원칙` 이다.

### 주 단위 빌드

주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다. 일주일의 첫 4일 동안은 서로를 신경 쓰지 않는다. 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다. 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는게 불가능해진다. 팀의 효율성도 서서히 나빠진다.

### 순환 의존성 제거하기

이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다. 이 같은 작업 절차는 단순하며 합리적이어서 널리 사용되는 방식이다. 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없는 구조여야한다. 이런 구조는 순환이 없다.

### 순환 끊기

- 의존성 역전 원칙을 적용한다. 중간에 인터페이스를 생성해서 두 컴포넌트가 직접적으로 의존하지 않도록 한다.
- 두 컴포넌트가 모두 의존하는 새로운 컴포넌트를 만든다.

### 흐트러짐(Jitters)

위에서 두번째 해결책의 경우, 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다. 실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다.

### 안정성 지표

어떻게 하면 컴포넌트 안정성을 측정할 수 있을까? 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보는 방법이 있을 수 있다.

- Fade-in : 안으로 들어오는 의존성. 컴포넌트 내부 클래스에 의존하는 외부의 클래스 개수
- Fade-out: 바깥으로 나가는 의존성. 외부 클래스에 의존하는 내부 클래스 개수
- I: 불안정성 I = fade-out / (fade-in + fade-out) 0과 1 범위의 값을 갖는다. 0이면 최고로 안정된 컴포넌틀 라는 뜻

**모든 컴포넌트가 안정적이어야 하는 것은 아니다**

다이어그램에서 변경 가능한 컴포넌트는 위쪽에, 아래에는 안정된 컴포넌트에 의존한다.

![IMG_0CF4C4D81ED5-1](https://github.com/jjiyeon/read-this-book/assets/15992851/5c121bdd-c04f-48dd-9446-d2442bfe28c9)

## 결론

지금 현재 리팩토링하는 프로젝트를 생각하면, 컴포넌트를 하향식으로 설계했을 경우에 순환의존성을 만드는것 같다. 작은 단위의 컴포넌트가 props에 의존하는 경우를 심심치않게 볼 수 있는데, 이 경우도 하향식으로 생각했기 때문아닐까. 특정 데이터 타입에만 의존하는 리스트라던지. 상향식으로 설계하는 습관을 만들어야 하는데, 쉽지가 않다. 의존성 역전을 위해 가운데에 인터페이스를 두는것, 이 경우를 좀 더 연습해 봐야 할 것 같다. Frontend에서 어떻게 시도해보면 좋을까.
