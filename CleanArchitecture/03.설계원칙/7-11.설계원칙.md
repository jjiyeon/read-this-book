# 3부. 설계원칙

좋은 소프트웨어 시스템은 깔끔한 코드(clean code)로 부터 시작한다. SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다. '클래스'라는 단어를 사용했다고 해서 SOLID 원책이 객체 지향 소프트웨어만 적용된다는 뜻은 아니다.

SOLID 원책의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

'중간 수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.

- SRP: 단일 책임 원칙(Single Responsibility Principle)
- OCP: 개방-폐쇄 원칙(Open-Closed Principle)
- LSP: 리스코프 치환 원칙(Liskov Substitution Principle)
- ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
- DIP: 의존성 역전 원칙(Dependency Inversion Principle)

## 7. SRP: 단일 책임 원칙

단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다. 헷갈리지 말라. 단 하나의 일만 해야 한다는 원칙은 따로 있다. 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙이다. 이 원칙은 더 저수준에서 사용된다.

SRP의 최종 버전은 아래와 같다.

> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

예를 들어, 한 클래스의 메서드를 사용하는 서로 다른 사용자(액터)가 결합되어 버리면 의존성이 높아지고 수정에 따라 중복으로 대응해야 할 코드가 늘어난다. 서로 다른 액터가 의존하는 코드를 서로 분리하자.

## 8. OCP: 개방-폐쇄 원칙

소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다. 다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.

서로 다른 목적으로 변경되는 요소를 적절하게 분리하고, 이들 요소 사이의 의존성을 체계화함으로써 변경량을 최소화할 수 있다.

모든 컴포넌트 관계는 단방향으로 이루어진다. A 컴포넌트에서 발생한 변경으로 부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다. 보호의 계층구조가 '수준 (level)'이라는 개념을 바탕으로 계층구조를 조직화 한다. 컴포넌트 계층 구조를 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

## 9. LSP: 리스코프 치환 원칙

초기에는 상속을 사용하도록 가이드하는 방법 정도로 간주되었다. 하지만 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해 왔다. 자바스러운 언어라면 인터페이스 하나와 이를 구현하는 여러개의 클래스로 구성된다.

## 10. ISP: 인터페이스 분리 원칙

-> 뭔가 위에서 설명하는 원칙들이 다 동일한 말을 하고 있는것 같은데...서로 다른 다른 객체가 A라는 클래스의 메서드를 의존하고 있을때, 불필요한 재컴파일과 재배포가 강제되는 상황이 발생되니, 분리하여 중간에 인터페이스로 필요한 함수만 구현체로 만들어서 사용하라는 설명으로 이해했다. 더 자세한건 13장에서.

## 11. DIP: 의존성 역전 원칙

의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.

### 안정된 추상화

안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.

- 변동성이 큰 구체 클래스를 참조하지 말라. 대신 추상 인터페이스를 참조하라
- 변동성이 큰 구체 클래스로부터 파생하지 말라. 상속은 아주 신중하게 사용해야 한다.
- 구체 함수를 오버라이드 하지 말라. 대체로 구체 함수는 소스 코드 의존성을 필요로 한다.
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

### 팩토리

변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다. 자바 등 대다수의 객체 지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.

구체적인 것들로부터 추상적인 것들을 분리한다. 소스코드 의존성은 해당 곡선과 교차할 때 모두 한 방향, 즉 추상적인 쪽으로 향한다. 추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함한다.

### 구체 컴포넌트

DIP 위배를 모두 없앨 수는 없다. 하지만 DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.
