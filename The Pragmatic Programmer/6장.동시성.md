# 6장 동시성

## **오늘 TIL 3줄 요약**

- 동시성 작업에서 어떤 데이터를 공유한다면 그건 틀린 상태인거다.
- 의존성을 없애고 각각의 액터(객체라고도 볼 수 있지 않을까?)가 자신의 상태를 메시지에 던져준다면(메시지는 일방향) 동시성의 문제를 해결할 수 있다.
- 칠판의 예제는 잘 이해가 안간다.

## 책에서 기억하고 싶은 내용

‘동시성'은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것이다. 그리고 ‘병렬성'은 실제로 동시에 실행되는 것이다.

동시성이나 병렬성을 지원하는 코드를 쓰는 건 왜 그렇게 어려울까? 한 가지 이유는 우리가 프로그래밍을 순차적 시스템으로 배워서다. 그리고 우리가 쓰는 언어의 기능이 순차적으로 사용할 때는 비교적 안전하지만, 동시에 두 가지 일이 일어날 수 있으면 골칫거리로 변해서다. 둘 이상의 코드 뭉치가 하나의 변경 가능한 데이터를 참조하고 있다면 공유 상태가 존재하는 것이다.

### 33. 시간적 결합 깨트리기

소프트웨어의 설계 요소로서 시간의 역할에 대해 이야기하려고 한다. 시간에는 우리가 신경 써야 할 측면이 두 가지가 있는데, 동시성(동시에 일어나는 일들)과 순서(시간의 흐름 속에서 일들의 상대적인 위치)다.

아키텍처를 설계하거나 프로그램을 짜기 시작할 때는 보통 직선적 사고를 하기 마련이다. 사람들의 사고방식이 대개 그렇다. ‘이것을 하고, 그런 다음에 저것을 하고'. 하지만 이런 식으로 생각하다 보면 시간적 결합을 만들게 된다. 메서드 A는 언제나 반드시 메서드 B보다 먼저 호출해야 한다. 보고서는 한 번에 오직 하나만 생성할 수 있다. 버튼 클릭을 처리하려면 먼저 화면이 갱신되어야 한다. 똑은 딱보다 먼저 일어나야 한다.

- 동시성 찾기
  우리는 동시에 일어나도 되는 게 뭐고, 반드시 순서대로 일어나야 하는 건 어떤 것인지 찾아내길 원한다. ‘활동 다이어그램 activity diagram' 같은 표기법을 사용해서 작업 흐름을 기록하는 것이 한 방법이다.
  활동 다이어그램은 모서리가 둥근 상자로 표현하는 활동들로 이루어진다. 한 활동에서 나가는 화살표는 다른 활동으로 갈 수 있는데, 화살표를 받은 활동은 이전 활동이 끝난 후 시작될 수 있다. 화살표는 ‘동기화 막대synchronization bar’로 갈 수도 있는데, 동기화 막대로 들어오는 활동이 모두 완료된 후에야 막대에서 나가는 화살표를 따라 진행할 수 있다. 자기에게 오는 화살표가 없는 활동은 언제든지 시작할 수 있다. 아래의 이미지와 같다
  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/75463a74-2d2d-4445-8610-13792c8726dc/Untitled.png)
- 동시 작업의 기회
  활동 다이어그램은 동시에 작업할 수 있는 부분들을 보여 준다. 하지만 진짜로 동시에 하는 것이 좋은지는 알려주지 않는다. 이것이 동시성을 고려한 설계를 할 때 찾아야 하는 것이다.
- 병렬 작업의 기회
  동시성은 소프트웨어 동작 방식이고, 병렬성은 하드웨어가 하는것이다.

### 34. 공유 상태는 틀린 상태

여러분이 가장 좋아하는 레스토랑에 방문했다. 애플파이가 있는지 종업원에게 묻는다. 종업원은 어깨 너머를 돌아 보니 진열장에 한조각이 남아 있는것을 확인하고 그렇다고 대답한다. 반대쪽에서도 다른 고객이 종업원에게 같은 질문을 하고 이 종업원도 진열장을 쳐다보고 한조각 있는것을 확인하고 주문을 받는다.

두 고객 중 한 명은 실망하게 될 것이다. 문제는 상태가 공유된 것이다.

이 경우 파이 조각을 가져오고 갱신하는 동작이 원자적 atomic이지 않기 때문이다. 실제 값이 그 사이에 바뀔 수 있다.

원자적으로 바꿀 수 있을까?

- 세마포어 및 다른 상호 배제 방법

  세마포어semaphore는 단순히 한 번에 한 사람만이 가질 수 있는 무언가다. 레스토랑에서는 세마포어로 파이 문제를 해결하기로 했다. 진열장 위에 도깨비 인형을 하나 올려 둔다. 모든 종업원은 파이 주문을 받기 전에 도깨비 인형을 손에 넣어야 한다. 주문을 받고 파이를 접시에 담아 고객에게 낸 후에는 도깨비 인형을 보물 파이를 지키는 원래 위치에 되돌려 놓는다.

  도깨비 인형을 세마포어로 비유했다. 코드에서 세마포어를 잠금lock/잠금 해제unlock/획득claim/반환release 등으로 부른다.
  여기서도 문제가 있다. 두 종업원이 동시에 세마포어를 얻으려고 시도하지만 한명만 성공한다. 확보한 쪽은 평소처럼 진해앟지만, 얻지 못한쪽은 세마포어를 얻을 수 있을때까지 멈춰있는다.

- 리소스를 트랜잭션으로 관리하라

  현재 설계가 미흡한 것은 진열장 사용을 보호할 책임을 진열장을 사용하는 사람에게 전가하기 때문이다. 제어를 중앙으로 집중시키자. 그러려면 종업원이 하나의 호출로 파이 조각 수를 확인함과 동시에 파이 조각을 가져가도록 만들어야 한다. 리소스 접근을 한곳으로 모으긴 했다. 하지만 여러 종업원이 동시에 호출 될 수 있으므로 세마포어 보호해야한다. 하지만 갑자기 세마포어를 가진 종업원에게 문제가 생긴다면? 예외를 발생 시키면 세마포어는 영영 잠금이 풀리지 않을것이고, 이후로 다른 종업원은 하염없이 기다려야 한다.

공유 메모리는 동시성 문제의 원인으로 많이 지목받는다. 하지만 사실 수정 가능한 리소스를 공유하는 애플리케이션 코드 어디에서나 동시성 문제가 발생할 수 있다.

### 35. 액터와 프로세스

액터actor와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다. 공유 메모리 접근을 동기화하느라 고생할 필요도 없다. 용어를 먼저 정의하자면..

- ‘액터'는 자신만의 비공개 지역상태state를 가진 독립적인 가상 처리 장치다. 각 액터는 우편함을 하나씩 보유하고 있고, 액터가 잠자고 있을때 우편함에 메시지가 도착하면 액터가 깨어나면서 메시지를 처리한다. 처리가 끝나면 다른 메시지를 처리한다. 메시지를 처리할 때 다른 액터를 생성하거나, 알고 있는 다른 액터에게 메시지를 보내거나, 새로운 상태를 생성할 수 있다.
- ‘프로세스'는 보통 운영체제가 동시성을 지원하기 위하여 구현한다. 프로세스를 사용할 때 마치 액터처럼 동작하여 제한적으로 사용할 수 있는데 여기서는 이 경우다.

액터는 언제나 동시성을 띤다. 위에서 찾아볼 수 없는것이 몇 가지 있다.

- 액터를 관리하는것 x
- 시스템이 저장하는 상태는 오직 메시지 그리고 각 액터의 지역 상태뿐
- 모든 메시지는 일방향
- 액터는 한번에 하나의 메시지만 처리

그 결과 액터들은 아무것도 공유하지 않으면서 비동기적으로 동시에 실행된다. 물리적인 프로세서가 넉넉하다면 각각 액터를 하나씩 돌릴 수 있다. 어느쪽이든 액터에서 실행되는 코드는 동일하다.

레스토랑 에시를 액터를 적용해보면 고객, 종업원, 진열장 이렇게 세 가지 액터가 있다. 종업원이 주문 메시지를 고객에게서 받으면 고객에 ‘파이'를 주문한 것인지 확인한다. 파이가 맞으면 진열장에 요청을 보낸다. 이때 고객과 자신의 참조를 함께 보낸다.

진열장은 상태를 가지고 있다. 종업원에게 한 조각 꺼내기 메시지를 받으면 남은 파이 조각이 있는지 확인한다. 파이가 있으면 고객에게 전달, 종업원에게 주문서 기록하라고 알려준다. 마지막으로 한조각이 줄어든 상태를 기록한다.

액터 모델에서는 동시성을 다루는 코드를 쓸 필요가 없다. 공유된 상태가 없기 때문이다. 액터가 수신하는 메시지에 따라 알아서 실행되기 때문이다.

### 36. 칠판

주택 담보 대출이나 신용 대출 신청을 받아서 처리하는 프로그램을 작성한다고 가정해 보자. 대출을 받기 위한 각 관장하는 기관 정부, 금융위원회, 지방 자치 단체에서는 모두 자신마의 규정이 있기 때문에 복잡하다. 준수해야 할 문제들은 다음과 같다. (+ 준수해야 할 법도 있다)

- 응답은 정해진 순서 없이 도착한다.
- 여러 표준 시간대에 걸쳐 있는 여러 사무실에 분산된 여러 사람이 데이터를 수집 할 수 있다.
- 어떤 데이터는 다른 시스템이 자동으로 해주기도 한다. (비동기적)
- 어떤 데이터는 다른데이터를 의존하기까지 한다.
- 새로운 데이터가 도착하면 새로운 질문을 하거나 새로운 정책을 적용해야 할 수 있다.

철판 시스템을 법적 요구 사항을 캡슐화하는 규칙 엔진과 함께 사용하면 이러한 어려움을 해결 할 수 있다. 어떤 사실이 칠판에 올라가면 적절한 규칙이 발동되도록 하면 된다. 결과에 대한 피드백도 마찬가지로 다시 칠판에 올려서 다른 규칙들이 발동되도록 하면 된다.

## **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**

클린코드에서 부터 실용주의 프로그래머까지 일맥상통하는 내용이 있다면 의존성을 없애고, 한가지 역할만 한다는 내용 아닐까 싶다. 위에서 설명한 액터도 공유 메모리에 의존하지 않고 자신의 지역상태만을 가지고 있으면서 한가지 일만 하면 동시성에서의 문제점을 해결할 수 있는것 처럼. 하지만 결국 이렇게 설계를 할 수 있는건 아마 내가 설계하고자 하는 기능에 대한 이해가 정리가 되어 있는 상태겠지. 프로젝트에 대한 이해도에 따라 코드도 달라질 수 있지 않을까 싶은 내용인것 같다. 동시성의 경우 늘 한번쯤은 공유 리소스로 이슈를 겪어봤을 테니까. 똑 딱을 이해해야 똑 다음에 딱이 온다는거다.

## **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

## **오늘 읽은 다른사람의 TIL**
